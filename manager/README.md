# O/Rマッパーを使用してデータベースへ接続する

## ORM

- MyBatis, JPAあたりがメジャー

## 導入

- mybatis, mysql-connector-javaがmybatis, mysqlを繋げるライブラリ
- dynamic-sql, mybatis-generator-coreがコード生成を行うもの

- `com.arenagod.gradle.MybatisGenerator`は`com.qqviaja.gradle.MybatisGenerator`に修正
- 設定ファイル`generatorConfig.xml`を作成
- gradleのコマンド`mbGenerator`を実行するとファイルが生成される

ファイル生成は`MybatisGenerator`の機能で`Mybatis`の機能ではない
実行すると各テーブルを表したモデルやマッパーが生成される
enum型は文字列として認識されてしまうのでカラムのオーバーライドを行うことによって書き換えるようにする

## 生成されるファイル

全てテーブル名が先に付いている

- Record → テーブルを表したモデル
- DynamicSqlSupport → Mapperを使用するクエリのカラム指定のパラメーターが記述されている
- Mapper → 基本的なクエリ発行の関数が定義されたインターフェース(クエリの結果のどのカラムがどれに該当するのかを表したもの)
- MapperExtensions → Mapperの関数の定義

## アプリケーション設定

- 設定はapplication.propertiesで行うことができるが最近はymlを使うことが多いので`application.yml`という名前に変更して記述する

## 関数の拡張

- 関数を拡張する場合はMapper, MapperExtensions, Recordを定義する必要がある
- Mapper → どのような関数を作るのか・その時の結果のマッピングはどういった感じになるのか(マッピングは他のものと結果が同じの場合idだけで良い)
- MapperExtensions → その実装

**kotlin関係**

- 一時的に使うだけの変数はクラスのフィールド名を差別化するため変数名の最初に_をつけると良い
- if (hoge != null)で処理をする場合はletと組み合わせる
- if (hoge == null)で処理をする場合はエルビス演算子:?を使う

## 関数が既に生成されている場合の取得方法

- 既にある場合はRepositoryインターフェースに関数を定義・実装してサービス・コントローラーで使うだけで良い

アノテーション
`@Transactional` 関数内の処理にトランザクションを貼り例外が発生した場合はロールバックを行う

# Spring Security

**5系と6系で大分違うので注意すること・5.8は6系への準備となっているのでそこも少し変わっている**

- 認証・認可といったセキュリティ周りはSpring Securityを使って行う
- スターターをインストールするだけでオッケー
- インストールするだけでデフォルトでBasic認証が追加される

## 大まかな流れ

基本的な方針としては用意されているインターフェースをどんどん実装していく
どのインターフェースを実装する必要があるのか・どのような関数があるのかは理解しておく必要がありそう

1. まずは設定ファイルを作成
    - `WebSecurityConfigurerAdapter`を継承・EnableWebSecurityアノテーションを付けること
    - ここでどのルートに認証が必要なのかどういった権限が必要なのか定義
    - ログインパスに来た場合どの値がどれに値するかを定義
    - 認証成功・失敗・未認証といった状態の時に実行するべき関数
    - 認証にはどの関数を使うのか
2. それぞれの要素に対応した認証サービスを作成
    - ユーザーはどういった形なのか・ユーザー名やパスワードに当たる変数はどれなのかを`UserDetails`型に当てはめて関数を実装することによって伝える
3. 各種状態に応じたハンドラーを実装
    - 認証に成功した場合
    - 認証に失敗した場合
    - 未認証の場合
    - 認可に失敗した場合

コントローラー内でユーザー情報を取得したい場合
`SecurityContextHolder`に全てのユーザー情報が保存されているのでそのオブジェクトをユーザーの扱い方を表したクラスにキャストして使用する

## Gradleのバージョン周り

- 複数のライブラリが特定のライブラリに依存している場合バージョンが高い方に統一されてしまう
- 記述しているライブラリと違うバージョンのライブラリがインストールされてしまう可能性がある
- 自力でバージョン解決をするか使っていないものをインストールされているものを整理したりする？
    - 強制的にバージョンを固定する方法もありそう？

https://docs.gradle.org/current/userguide/dependency_downgrade_and_exclude.html#sec:strict-version-consequences
https://kkoudev.github.io/blog/2014/03/30/gradle-tips/

## セッション管理

- `@EnableRedisHttpSession`を使うことによってセッションがSpringのインメモリからRedisに保存するようにすることができる
- 中にRedisの接続情報を入れるだけで良さそう

# Spring AOP

- AOP → ロギングのように様々なオブジェクトを切り出し各オブジェクトから直接呼び出さず実行される共通処理として定義するプログラミングパラダイム
- Spring AOP → AOPを実現するライブラリ
- AOPにおいてAdviceは横断的関心ごとの処理を定義するものを指す

## 処理タイミング

- 処理タイミングはアノテーションで定義できる

- Before, After → 特定の処理の前後
- Around → Before, Afterを一つのアノテーションで定義
- AfterReturning → 戻り値を取得して処理
- AfterThrowing → 例外が発生した時

# JUnitでの単体テスト

- インストール時に`testImplementation`をつけたものはtestパッケージ内でのみ使用可能(mainでは使用できない)
- テストはテストパッケージ内とmainパッケージ名の場所が同じ名前になるようにするのが良い→同じパッケージのクラスとして扱われimportの記述が不要となる
- `Test`アノテーションを付けた場合のみテストとして認識される

- 帰ってきた値が正しいか
- 関数に対して意図した引数で実行されているか
- 特定の関数の呼び出し回数は何回か
