# OOP

# クラス定義
コンストラクタを作成せずにクラスの関数宣言時にvarやvalをつけることによってその値をプロパティとして定義することができる
コンストラクタは2種類存在する
- Primary Constructor → 与えられた値を元に初期化する
- Secondary Constructor → 与えられなかった値に対して初期化する？

## Primary Constructor
- クラス定義時に引数として入れるものもPrimary Constructor?
initializer blocks→コンストラクタのようなもの？初期化時に1行以上実行することができるようになる
- init関数を使ってその中で初期化していく

クラスの中で要素にアクセするには"this"を使用する
- printの中でアクセスする時は従来通り"$"でアクセス

## Secondary Constructor
constructor関数を使って初期化
引数としてどの値を取るかによってどのように初期化するかを決定することができる
複数定義可能
役割としてはPrimary Constructorを受け取って初期化する

## デフォルト値
Primary Constructorにてデフォルト値の定義をすることもできる
  - Secondary Constructorでデフォルト値の代入がしたいだけならこれで良いかも
処理がしたいのであればinitializer blocksで良い気がする

## 名前付き引数
インスタンス時に名前指定して引数として渡すこともできる
プライマリーコンストラクターでのみ有効

# Getter and Setters
- 値を取得・変更する時はgetter, setterを使ってね
  - 何もしなくてもドットでアクセスすることによって自動的に呼ばれる
  - setterについてもその値に対して代入するだけで作ることができる
- 値をvalとして定義している場合getterしかできない
- 上書きしたい場合は自分で初期化した上で上書き
- カスタムのget, setを作りたいばあい以外は自力で書く必要がない

# Lateinit keyword
- クラスの中で値を宣言した時はその宣言時に値を入れる必要がある
  - 現状ではinit関数ないで宣言することができる
  - それ以上後で宣言したい場合は？
- プロパティ定義時にlateinitキーワードを入れる
- 通常のgetterと同じ容量で入れることができる
  - 入れる前にアクセスしようとした場合エラーが出る
  - lateinitを宣言している場合専用の処理をするためnull pointer exceptionにはならない
- int, boolには使えない

# Companion Object
インスタンス時に値を受けないもののメソッドを呼び出す時に毎回インスタンスをするのがめんどくさい
→companion objectを使う
companion object関数の中に関数を入れるだけで良い
→その関数はクラスの中の関数ではなくなる

クラス自体には所属せずクラス関数として扱われる
クラス.関数をインスタンスなしで実行できるようになる
オブジェクトを作る必要なくインスタンスもする必要ない

関数のみならず値も入れることができる
もちろんそのクラスの中からもアクセスすることができる
- 特にthisなどはつけずに普通にアクセス
