# OOP

# クラス定義
コンストラクタを作成せずにクラスの関数宣言時にvarやvalをつけることによってその値をプロパティとして定義することができる
コンストラクタは2種類存在する
- Primary Constructor → 与えられた値を元に初期化する
- Secondary Constructor → 与えられなかった値に対して初期化する？

## Primary Constructor
- クラス定義時に引数として入れるものもPrimary Constructor?
initializer blocks→コンストラクタのようなもの？初期化時に1行以上実行することができるようになる
- init関数を使ってその中で初期化していく

クラスの中で要素にアクセするには"this"を使用する
- printの中でアクセスする時は従来通り"$"でアクセス

## Secondary Constructor
constructor関数を使って初期化
引数としてどの値を取るかによってどのように初期化するかを決定することができる
複数定義可能
役割としてはPrimary Constructorを受け取って初期化する

## デフォルト値
Primary Constructorにてデフォルト値の定義をすることもできる
  - Secondary Constructorでデフォルト値の代入がしたいだけならこれで良いかも
処理がしたいのであればinitializer blocksで良い気がする

## 名前付き引数
インスタンス時に名前指定して引数として渡すこともできる
プライマリーコンストラクターでのみ有効

# Getter and Setters
- 値を取得・変更する時はgetter, setterを使ってね
  - 何もしなくてもドットでアクセスすることによって自動的に呼ばれる
  - setterについてもその値に対して代入するだけで作ることができる
- 値をvalとして定義している場合getterしかできない
- 上書きしたい場合は自分で初期化した上で上書き
- カスタムのget, setを作りたいばあい以外は自力で書く必要がない

# Lateinit keyword
- クラスの中で値を宣言した時はその宣言時に値を入れる必要がある
  - 現状ではinit関数ないで宣言することができる
  - それ以上後で宣言したい場合は？
- プロパティ定義時にlateinitキーワードを入れる
- 通常のgetterと同じ容量で入れることができる
  - 入れる前にアクセスしようとした場合エラーが出る
  - lateinitを宣言している場合専用の処理をするためnull pointer exceptionにはならない
- int, boolには使えない

# Companion Object
インスタンス時に値を受けないもののメソッドを呼び出す時に毎回インスタンスをするのがめんどくさい
→companion objectを使う
companion object関数の中に関数を入れるだけで良い
→その関数はクラスの中の関数ではなくなる

クラス自体には所属せずクラス関数として扱われる
クラス.関数をインスタンスなしで実行できるようになる
オブジェクトを作る必要なくインスタンスもする必要ない

関数のみならず値も入れることができる
もちろんそのクラスの中からもアクセスすることができる
- 特にthisなどはつけずに普通にアクセス

# シングルトン
- クラス内でオブジェクトを管理しても良いが最も簡単な方法としてはobjectとして定義すること
- 初期化処理に関してもクラス同様initを使うことができてその時に処理ができる

# Lazy initialization
- クラス初期化処理が重い時に使う
- 作成時にby lazyで囲むと使える
- 該当のオブジェクトをコード上で使われたタイミングでインスタンス化される

# enum
- クラスとして定義する必要がありそう？
- クラスということもあって引数を渡すことができる
  - enumの中でオブジェクトを入れ込みたい場合は引数が必須
- 中に関数を入れ込むこともできる
  - enumの最終行にセミコロンが必須

# Inner Class
- クラスの中で定義されたクラス
- クラスの外の値にアクセスできる
- あまり定義するメリットがわからない

# Inheritance
- 継承するにはopen classである必要がある
- 継承時にコンストラクタ内で値を渡すことによって継承元でインスタンスかされる？

- 関数のオーバーライドをするにはベースとなる関数にopenキーワードを指定する
  - 書き換え先でoverrideを指定してから書く

# sealed class
- enumでも行けるが型が複雑な場合に使う？
- whenの中で使う時も完全に形を決めることができる
- サブクラスの中身を制限することができる→それによって型を決めることができる

# abstract classes
- インターフェースに似ている
- 違いは値を持ったプロパティを定義することができること
- abstract classは他のクラスに継承される必要がある・単体でのインスタンス化は不可能
- 値が欲しいインターフェースでコード生成などに使われる？ とりあえずインターフェースの知識をつける

# data class
structural equality と referential equality
- structuralの場合単純に値が同じかを確認する
  - イコール2つで判定できる
- referential equalityの場合そのオブジェクトがメモリ上で同じかを確認する
  - イコール3つで判定できる

- kotlinではクラスはどれも？anyクラスが継承されていて比較時にデフォルトの比較用の関数が実行される
- 比較させるためには自分達でそれらの関数を上書きする必要がある
  - equals 比較用の関数 ==時に呼び出し
  - hashCode パフォーマンス周り
  - toString 出力時の形を定義することができる 出力時に呼び出し
- equalsをオーバーライドした場合はhashcodeも上書きする必要がある

**実はこれらは必要ない**

- classの前にdataキーワードを入れることによってそれらは自動的に生成される
- ただしプライマリーコンストラクタ内に入っている値しかみてくれない

# interfaces
- 関数の名前とパラメーターのみ決めて実装は任せる場合に使用
- interfaceキーから開始する
- 名前は大文字スタートで必要に応じてパスカルケースがおすすめ
- コンストラクタは持てない
- 継承と同じ方式で実装を指定


